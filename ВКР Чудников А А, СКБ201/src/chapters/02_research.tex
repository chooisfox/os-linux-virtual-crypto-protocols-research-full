\section{Аналитическая часть}

\subsection{Разработка и эксплуатация модулей ядра}

Для разработки модулей, реализующих необходимые криптографические протоколы, в первую очередь, необходимо разобраться в том, как эти самые модули работают в контексте ядра. Для этого нужно рассмотреть их структуру, жизненный цикл, процесс сборки и методы их отладки.

\subsubsection{Структура и программная реализация}

Любой модуль ядра должен придерживаться определенного соглашения о том, как он должен выглядеть с точки зрения реализации.
В отличие от стандартного приложения написанного на языке <<\texttt{C}>>, в модулях отсутствует стандартная точка входа в виде функции \mintinline{c}{main()}, вместо этого в модулях используются специальные макросы, которые позволяют реализовать точки входа и выхода из модуля.\\

Для того чтобы модуль считался валидным, он должен содержать как минимум следующее:
\begin{itemize}
    \item \textbf{Заголовочные файлы ядра}: обеспечивают доступ к внутренним структурам и функциям API ядра (например, \texttt{<linux/module.h>}, \texttt{<linux/kernel.h>});
    \item \textbf{Макросы инициализации}: \mintinline{c}{module_init()} указывает ядру, какую функцию вызвать при загрузке;
    \item \textbf{Макросы завершения}: \mintinline{c}{module_exit()} указывает функцию для очистки ресурсов при выгрузке;
    \item \textbf{Метаданные}: макросы \mintinline{c}{MODULE_LICENSE}, \mintinline{c}{MODULE_AUTHOR} и другие, описывающие модуль для утилит управления.
\end{itemize}

Ниже представлен минимальный пример модуля ядра на языке <<\texttt{C}>>:

\input{src/embeds/code/50_module_minimal_example.tex}

\subsubsection{Система сборки Kbuild}

Для сборки модулей ядра требуется полная бинарная совместимость символов и структур данных с ядром, для которого собирается модуль, именно поэтому сборка модулей происходит в контексте исходного кода ядра необходимой версии.
Для этого используется система сборки <<\texttt{Kbuild}>>. Обычно для автоматизации процесса сборки используется скрипт \texttt{Makefile}, в котором автоматически указывая путь к заголовочным файлам (\texttt{linux-headers}) и список необходимых объектных файлов.\\

Примерно так будет выглядеть минимальный \texttt{Makefile} для сборки модуля ядра:
\input{src/embeds/code/51_minimal_makefile_example.tex}

Результатом успешной сборки будет объектный файл модуля с расширением (\texttt{.ko — kernel object}).
Такой объект может быть загружен в ядро \texttt{Linux}.

\subsubsection{Управление загрузкой}

Для работы с загружаемыми модулями в ОС \texttt{Linux} предусмотрены специальные утилиты:
\begin{itemize}
    \item \mintinline{bash}{insmod <путь_к_файлу.ko>}: загружает модуль в ядро. При этом выполняется его \mintinline{c}{init} функция;
    \item \mintinline{bash}{rmmod <имя_модуля>}: выгружает модуль из ядра. При этом выполняется \mintinline{c}{exit} функция;
    \item \mintinline{bash}{lsmod}: показывает список всех загруженных на данный момент модулей;
    \item \mintinline{bash}{modprobe}: более высокоуровневая утилита, которая умеет автоматически загружать модуль вместе с его зависимостями, используя базу данных модулей.
\end{itemize}

Информацию о загруженных модулях также можно посмотреть в \mintinline{bash}{/proc/modules} и \mintinline{bash}{/sys/module}.

\subsubsection{Методы отладки в пространстве ядра}

Отладка кода, работающего в пространстве ядра, является намного более сложной задачей, нежели отладка обычного приложения.
В контексте ядра любая критическая ошибка (например, разыменование \texttt{NULL}-указателя) может привести к полной остановке системы --- состоянию \texttt{Kernel Panic}.
Стандартные отладчики (\texttt{GDB}) здесь применимы только при использовании виртуальных машин или аппаратных \texttt{JTAG}-интерфейсов.

\begin{itemize}
    \item \textbf{Отладка с помощью \texttt{printk}}: самый простой и распространенный способ --- вставка отладочных сообщений в код. \texttt{printk} позволяет указывать уровень важности сообщения (например, \texttt{KERN\_INFO}, \texttt{KERN\_DEBUG}). Уровнем вывода сообщений на консоль можно управлять через \texttt{/proc/sys/kernel/printk}. Для удобства трассировки часто используются предопределенные макросы \texttt{\_\_FILE\_\_}, \texttt{\_\_LINE\_\_} и \texttt{\_\_func\_\_};

    \item \textbf{Анализ \texttt{Kernel Oops}}: "\texttt{Oops}" --- это сообщение о некритической ошибке ядра. В отличие от "\texttt{Panic}" система пытается продолжить работу, но её состояние уже нестабильно. Такое сообщение содержит в себе ключевую информацию для отладки:
    \begin{itemize}
        \item причина ошибки (\texttt{BUG: unable to handle kernel paging request});
        \item адрес инструкции, вызвавшей сбой, и смещение внутри функции (\texttt{EIP is at my\_oops\_init+0x5/0x20});
        \item код ошибки, который описывает тип операции (чтение/запись, режим ядра/пользователя);
        \item состояние регистров и трассировку стека вызовов (\texttt{Call Trace}).
    \end{itemize}

    \item \textbf{Использование \texttt{objdump} и \texttt{addr2line}}: имея адрес инструкции из сообщения "\texttt{Oops}" и базовый адрес загрузки модуля (из \texttt{/proc/modules}), можно точно определить строку в исходном коде, которая привела к сбою.
    \begin{itemize}
        \item \texttt{objdump}: дизассемблирует код модуля, сопоставляя его с исходным кодом;
        \begin{minted}{bash}
objdump -dS --adjust-vma=<базовый_адрес> module.ko
        \end{minted}
        \item \texttt{addr2line}: преобразует смещение адреса внутри функции в номер строки исходного кода.
        \begin{minted}{bash}
addr2line -e module.o <смещение>
        \end{minted}
    \end{itemize}

    \item \textbf{Динамическая отладка (\texttt{dyndbg})}: более гибкая методика, позволяющая включать и выключать отладочные сообщения (\texttt{pr\_debug()}) на лету, без повторной сборки модуля. Для этого ядро должно быть собрано с опцией \texttt{CONFIG\_DYNAMIC\_DEBUG}. Управление осуществляется через запись в файл \texttt{/sys/kernel/debug/dynamic\_debug/control}, позволяя фильтровать сообщения по имени файла, функции, номеру строки или формату сообщения;

    \item \textbf{Отладчик ядра (\texttt{KDB/KGDB})}: для сложной отладки можно использовать встроенный отладчик ядра \texttt{KDB}. Он позволяет останавливать выполнение ядра, устанавливать точки останова (\texttt{breakpoints}), просматривать и изменять содержимое памяти и регистров в <<живой>> системе, обычно через последовательный порт.
\end{itemize}


\subsection{Архитектура и регистрация криптографических модулей}

Разработка собственного криптографического модуля в ядре \texttt{Linux} является довольно тривиальной задачей.
В ядре существует базовая структура, которая описывает базовые свойства алгоритма, на основе которой уже строятся структуры алгоритмов необходимого типа.

\subsubsection{Структура дескриптора алгоритма}

Базовым строительным блоком подсистемы является структура \mintinline{c}{struct crypto_alg}. Она содержит метаданные, необходимые для того, чтобы ядро смогло идентифицировать алгоритм и в дальнейшем выбрать наилучшую реализацию и управлять памятью.~\cite{linux_crypto_alg}

\input{src/embeds/code/52_crypto_alg_struct}

\subsubsection{Классификация криптографических примитивов}

Архитектура \texttt{Crypto API} классифицирует алгоритмы не только по их функциональному назначению, но и по способу взаимодействия с памятью. Каждому классу соответствует свой набор абстракций и структур данных.

\nlparagraph{Основные типы алгоритмов}

\begin{itemize}
    \item \textbf{CIPHER (Базовые блочные шифры):} низкоуровневый синхронный интерфейс для преобразования одного блока данных. Используется как строительный элемент для более сложных режимов;

    \item \textbf{SKCIPHER (Симметричные шифры):} основной \texttt{API} для шифрования данных произвольной длины (потоков). Работает с фрагментированной памятью (\texttt{scatterlist}) и поддерживает векторы инициализации, что делает его пригодным для обработки сетевых пакетов;

    \item \textbf{AKCIPHER (Асимметричные шифры):} \texttt{API} для алгоритмов с открытым ключом, таких как \texttt{RSA}, выполняющих операции шифрования/расшифрования небольших объемов данных (например, других ключей);

    \item \textbf{AEAD (Аутентифицированное шифрование):} ключевой тип для современных защищенных протоколов. Объединяет шифрование и вычисление имитовставки (\texttt{MAC}) в одну атомарную операцию. Это позволяет гарантировать не только конфиденциальность, но и целостность/подлинность данных (например, связки \texttt{AES-GCM} или <<Кузнечик-\texttt{MGM}>>);

    \item \textbf{HASH (SHASH / AHASH):} интерфейсы для вычисления хэш-сумм и кодов аутентификации (\texttt{HMAC}). Разделены на синхронный (\texttt{shash}) --- для быстрых программных реализаций, и асинхронный (\texttt{ahash}) --- для аппаратных ускорителей;

    \item \textbf{KPP (Протоколы согласования ключей):} \texttt{API} для реализации механизмов асимметричной криптографии, используемых для выработки общего секрета, например, \texttt{Diffie-Hellman}, \texttt{ECDH} и \texttt{VKO}. Это основа для этапа рукопожатия (\texttt{handshake});

    \item \textbf{SIG (Цифровые подписи):} специализированный \texttt{API} для создания и проверки цифровых подписей (например, \texttt{ECDSA}, \texttt{RSA-PSS}). В отличие от \texttt{AKCIPHER}, фокусируется на операциях \texttt{sign} и \texttt{verify};

    \item \textbf{COMPRESSION (SCOMP/ACOMP):} интерфейсы для синхронного (\texttt{scomp}) и асинхронного (\texttt{acomp}) сжатия данных;

    \item \textbf{RNG (Генераторы случайных чисел):} предоставляет доступ к источникам энтропии для генерации ключей, векторов инициализации и других криптографических материалов.
\end{itemize}

В данной работе нас интересуют три следующих типа алгоритмов: \texttt{hash}, \texttt{aead} и \texttt{kpp}.

\nlparagraph{Хэш-функции (SHASH / AHASH)}

Данный тип алгоритма \texttt{Crypto API} позволяет реализовать алгоритм и процедуру вычисления хэш-функции (в данном случае, ГОСТ Р 34.11-2012 <<Стрибог>>)~\cite{gost_34_11_2012}, а также кодов аутентификации сообщений (\texttt{HMAC}). Работа с \texttt{API} строится на итеративной обработке данных и управлении внутренним состоянием алгоритма. Для реализации подобного алгоритма необходимо реализовать набор функций-обработчиков, описывающих жизненный цикл вычисления:

\begin{itemize}
    \item \textbf{\texttt{init}}: инициализирует контекст хэш-функции, загружая в него начальные значения, стандартизованные для данного алгоритма;
    \item \textbf{\texttt{update}}: принимает на вход очередной фрагмент данных и обновляет внутреннее состояние. Может вызываться многократно для обработки больших сообщений;
    \item \textbf{\texttt{final}}: завершает вычисление. Выполняет финальное дополнение (padding) сообщения, производит последнюю итерацию функции сжатия и записывает итоговый дайджест в выходной буфер.
\end{itemize}

Для регистрации такого алгоритма необходимо заполнить структуру \mintinline{c}{shash_alg}.~\cite{linux_crypto_hash}

\input{src/embeds/code/53_crypto_hash_example}

\nlparagraph{Аутентифицированное шифрование (AEAD)}

Данный тип алгоритма \texttt{Crypto API} предназначен для реализации процедур аутентифицированного шифрования (в данном случае, <<Кузнечик>> в режиме \texttt{MGM}). \texttt{API} этого типа атомарно обеспечивает конфиденциальность и целостность, что является стандартом для защиты сетевого трафика. Для реализации подобного алгоритма необходимо реализовать две основные функции:

\begin{itemize}
    \item \textbf{\texttt{encrypt}}: получает на вход открытый текст, вектор инициализации (IV) и ассоциированные данные (заголовки, которые не шифруются, но защищаются от подмены). На выходе формирует шифротекст и тег аутентификации (имитовставку);
    \item \textbf{\texttt{decrypt}}: выполняет обратную операцию. Функция принимает шифротекст, IV, ассоциированные данные и тег. Она самостоятельно вычисляет тег для полученных данных и сравнивает его с уже переданным. Только в случае полного совпадения расшифрованный текст считается валидным, иначе возвращается ошибка, предотвращая обработку поддельных пакетов.
\end{itemize}

Регистрация AEAD-алгоритма производится через структуру \mintinline{c}{aead_alg}.~\cite{linux_crypto_aead}

\input{src/embeds/code/54_crypto_aead_example}

\nlparagraph{Протоколы согласования ключей (KPP)}

Данный тип алгоритма \texttt{Crypto API} реализует асимметричные примитивы, необходимые для выработки общего секрета (в данном случае это VKO на базе ГОСТ Р 34.10-2012). API предоставляет три основные операции:

\begin{itemize}
    \item \textbf{\texttt{set\_secret}}: загружает собственный закрытый ключ в контекст алгоритма;
    \item \textbf{\texttt{generate\_public\_key}}: вычисляет публичный ключ, соответствующий ранее загруженному закрытому ключу;
    \item \textbf{\texttt{compute\_shared\_secret}}: принимает на вход публичный ключ удаленной стороны и, используя свой закрытый ключ, вычисляет общий секрет, который в дальнейшем используется для генерации сессионных симметричных ключей.
\end{itemize}

Регистрация KPP-алгоритма производится через структуру \mintinline{c}{kpp_alg}.~\cite{linux_crypto_kpp}

\input{src/embeds/code/55_crypto_kpp_example}

\subsection{Анализ криптографической архитектуры WireGuard}

Главным этапом подготовки к адаптированию \texttt{WireGuard} на криптографические протоколы стандартизированные в ГОСТ является анализ архитектуры \texttt{WireGuard} на предмет того, где и какие протоколы в нем используются. \\

Реализация \texttt{WireGuard} довольно проста, и практически вся интересующая информация может быть найдена в файлах: \texttt{noise.c}, \texttt{device.c}, \texttt{send.c}/\texttt{receive.c} и \texttt{cookie.c}.

В центре самого \texttt{WireGuard} располагается \texttt{noise.c}. Он реализует машину состояний протокола рукопожатия на базе фреймворка \texttt{Noise Protocol Framework} (шаблон \texttt{IKpsk2}). \\

\subsubsection{\texttt{Noise Framework}}

В основе логики \texttt{WireGuard} лежит протокол \texttt{Noise}, который представляет собой не единый алгоритм, а конструктор протоколов. Автор \texttt{WireGuard} выбрал конкретную конфигурацию — \textbf{Noise\_IKpsk2}. Эта строка конфигурации жестко зашита в исходном коде ядра и определяет последовательность криптографических операций. ~\cite{wireguard} \\

В файле \texttt{noise.c} эта конфигурация определяется следующим образом:~\cite{linux_net_wireguard_noise}

\begin{minted}{c}
static const u8 handshake_name[37] __nonstring =
    "Noise_IKpsk2_25519_ChaChaPoly_BLAKE2s";
\end{minted}

На основе этой строки можно примерно представить список криптографических примитивов, которые в дальнейшем необходимо будет заменить:
\begin{itemize}
    \item \textbf{IKpsk2}: Паттерн рукопожатия. Означает, что статический ключ инициатора передается сразу (\texttt{I}), статический ключ респондера известен заранее (\texttt{K}), используется пре-распределенный ключ (\texttt{psk}) и обмен завершается за 2 сообщения;
    \item \textbf{25519}: Алгоритм Диффи-Хеллмана на кривой \texttt{Curve25519};
    \item \textbf{ChaChaPoly}: \texttt{AEAD}-шифр \texttt{ChaCha20-Poly1305};
    \item \textbf{BLAKE2s}: Хэш-функция.
\end{itemize}

\nlparagraph{Обмен ключами (Key Exchange)}

\textbf{Текущая реализация:}\\

В оригинальном протоколе используется эллиптическая кривая \texttt{Curve25519}. В исходном коде (\texttt{noise.c}) ключевой функцией является \mintinline{c}{mix_dh}, которая выполняет умножение точки на скаляр и обновляет состояние цепочки ключей.~\cite{linux_net_wireguard_noise}

\begin{minted}{c}
static bool __must_check mix_dh(u8 chaining_key[NOISE_HASH_LEN],
                                u8 key[NOISE_SYMMETRIC_KEY_LEN],
                                const u8 private[NOISE_PUBLIC_KEY_LEN],
                                const u8 public[NOISE_PUBLIC_KEY_LEN])
{
    u8 dh_calculation[NOISE_PUBLIC_KEY_LEN];

    if (unlikely(!curve25519(dh_calculation, private, public)))
        return false;

    kdf(chaining_key, key, NULL, dh_calculation, NOISE_HASH_LEN,
        NOISE_SYMMETRIC_KEY_LEN, 0, NOISE_PUBLIC_KEY_LEN, chaining_key);
    /* ... */
}
\end{minted}

\textbf{Адаптация под ГОСТ:}\\

Согласно ГОСТ Р 34.10-2012 алгоритм \texttt{Curve25519} следует заменить на алгоритм \texttt{VKO} (выработка ключа обмена).\\

Алгоритм \texttt{VKO} (Выработка Ключа Обмена) является прямым функциональным аналогом (изоморфным примитивом) для ECDH среди протоколов стандартизированных ГОСТ. Он реализует операцию умножения точки эллиптической кривой (открытого ключа одной стороны) на скаляр (закрытый ключ другой стороны) для получения общей точки, координаты которой используются в качестве общего секрета. \texttt{VKO} идеально ложится в эту схему, меняя лишь математическую основу, логика работы протокола при этом остается неизменной.

\textbf{Проблемы реализации:}
\begin{itemize}
    \item \textbf{Размер ключей:} \texttt{Curve25519} использует 32-байтные ключи. В ГОСТ Р 34.10-2012 использует 64-байтные публичные ключи (в виде двух координат по 32 байта). Для корректной работы необходимо будет обновить структуры хранящие в себе информацию о пирах (\texttt{struct wg\_peer})
    и исправить формата пакетов рукопожатия, так как старые заголовки не вместят ключи увеличенного размера;
    \item \textbf{Endianness:} \texttt{WireGuard} работает с little-endian числами, тогда как в криптографии ГОСТ используется big-endian.
\end{itemize}

\nlparagraph{Симметричное шифрование (AEAD)}

\textbf{Текущая реализация:} \\

Для защиты как сообщений рукопожатия, так и полезной нагрузки (IP-пакетов) используется \textbf{ChaCha20-Poly1305}. Это крайне быстрый с точки зрения производительности поточный шифр. Вызов шифрования в \texttt{send.c} выглядит так: ~\cite{linux_net_wireguard_send}

\begin{minted}{c}
/* send.c - функция encrypt_packet */
return chacha20poly1305_encrypt_sg_inplace(sg, plaintext_len, NULL, 0,
                                           PACKET_CB(skb)->nonce,
                                           keypair->sending.key);
\end{minted}


\textbf{Адаптация под ГОСТ:}
В качестве замены схеме \texttt{ChaCha20-Poly1305} была выбрана комбинация блочного шифра <<Кузнечик>> в режиме гаммирования с мультипликативной имитовставкой — \texttt{MGM} (\texttt{Multilinear Galois Mode}), регламентированном в рекомендациях \texttt{Р 1323565.1.026—2019}.~\cite{gost_34_12_2018} \\

Оригинальный \texttt{WireGuard} использует \texttt{AEAD}-схему (\texttt{Authenticated Encryption with Associated Data}).
Это означает, что алгоритм должен не только шифровать данные, но и вычислять криптографически стойкую контрольную сумму (\texttt{Tag}) от зашифрованного текста и открытых заголовков пакета (\texttt{Associated Data}).
Режим \texttt{MGM} является единственным современным отечественным стандартом, который архитектурно соответствует требованиям \texttt{AEAD}. \\

Хотя <<Магма>> быстрее <<Кузнечика>> в программной реализации, она имеет размер блока 64 бита. В высоконагруженных VPN-каналах (1 Гбит/с и выше) это создает риск коллизий блока уже после передачи нескольких десятков гигабайт данных (атака \texttt{Sweet32}).~\cite{sweet_32_attack} Для долгоживущих туннелей использование 64-битных блочных шифров в современной криптографии считается небезопасным. <<Кузнечик>> с блоком 128 бит лишен этого недостатка.


\textbf{Проблемы реализации:}
\begin{itemize}
    \item \textbf{Производительность:} <<Кузнечик>> в отличие от \texttt{ChaCha20} намного более тяжеловесный блочный шифр (SP-сеть). Без использования оптимизации в виде векторных инструкций (AVX2/AVX-512) или аппаратного ускорения пропускная способность упадет в разы по сравнению с \texttt{ChaCha20};
    \item \textbf{Паддинг и выравнивание:} \texttt{ChaCha20} в отличие от <<Кузнечика>> является поточным шифром, ему не важна длина данных. <<Кузнечик>> --- блочный (128 бит), так что для корректной его работы необходимо использовать режим MGM, который позволит ему работать как поточный шифр. Это значительно усложнит его реализацию.
\end{itemize}


\nlparagraph{Хэширование и KDF}

\textbf{Текущая реализация:}

Функция \texttt{BLAKE2s} используется везде: для вычисления хэша сессии (\texttt{h}), для деривации ключей (\texttt{HKDF}) и для вычисления MAC в \texttt{cookie.c}.~\cite{linux_net_wireguard_noise,linux_net_wireguard_cookie}

\begin{minted}{c}
/* noise.c - обновление хэша сессии */
static void mix_hash(u8 hash[NOISE_HASH_LEN], const u8 *src, size_t src_len)
{
    struct blake2s_ctx blake;
    blake2s_init(&blake, NOISE_HASH_LEN);
    blake2s_update(&blake, hash, NOISE_HASH_LEN);
    blake2s_update(&blake, src, src_len);
    blake2s_final(&blake, hash);
}
\end{minted}

\begin{minted}{c}
/* cookie.c */
static void compute_mac1(...) {
    blake2s(key, NOISE_SYMMETRIC_KEY_LEN, message, len, mac1, COOKIE_LEN);
}
\end{minted}

\textbf{Адаптация под ГОСТ:}
Необходима замена на функцию <<Стрибог>> с длиной выхода 256 бит. \\

Выбор 256-битной версии <<Стрибога>> позволяет сохранить размерность внутренних структур данных (хэш сессии, цепочка ключей), идентичную оригиналу. Это минимизирует вмешательство в логику машины состояний \texttt{Noise}: меняется лишь математическая реализация функции сжатия, но не формат данных, передаваемых между этапами рукопожатия.\\

\textbf{Проблемы реализации:}
\begin{itemize}
    \item \textbf{Контекст выполнения:} Хэширование в \texttt{WireGuard} часто происходит на "горячем пути" (hot path). <<Стрибог>> значительно медленнее \texttt{BLAKE2s}. Это может замедлить скорость установки соединений, особенно под большой нагрузкой;
    \item \textbf{HMAC конструкция:} \texttt{BLAKE2s} имеет встроенный режим \texttt{keyed-hashing}. <<Стрибог>> требует использования классической конструкции \texttt{HMAC}, что добавляет лишние вызовы функции сжатия;
    \item \textbf{DDoS атаки:} <<Стрибог>> значительно замедляет скорость генерации MAC-контрольных сумм, проверка MAC1 происходит для каждого входящего пакета рукопожатия. Это может увеличить эффективность DDoS атак на сервер.
\end{itemize}

\subsection{Обзор отечественных криптографических стандартов}

Для обеспечения защиты информации в соответствии с требованиями регулятора ФСТЭК, в модифицированную версию \texttt{WireGuard} интегрируются алгоритмы, определенные в стандартах ГОСТ. Ниже приведено детальное описание их криптографической структуры.

\subsubsection{Алгоритм хэширования ГОСТ Р 34.11-2012 <<Стрибог>>}

В качестве основы для механизмов контроля целостности, защиты от DoS-атак и деривации ключей используется функция хэширования, определенная в ГОСТ Р 34.11-2012. В рамках данной работы применяется версия алгоритма с длиной хэш-кода 256 бит, что позволяет сохранить совместимость с размерностью внутренних структур протокола \texttt{WireGuard}. ~\cite{gost_34_11_2012}\\

Алгоритм реализует функцию сжатия на основе блочного шифра с архитектурой SP-сети (Substitution-Permutation network) и использует итерационную конструкцию Меркла-Дамгарда. Все операции выполняются над векторами из пространства $V_{512}$ (двоичные векторы длины 512 бит).

\nlparagraph{Базовые преобразования}

Математический аппарат алгоритма строится на композиции четырех преобразований, определенных для векторов $a \in V_{512}$:

\begin{enumerate}
    \item \textbf{Преобразование $X$ (XOR)}:
    Покомпонентное сложение двух векторов по модулю 2. Для $k, a \in V_{512}$:
    \[
    X[k](a) = k \oplus a
    \]

    \item \textbf{Преобразование $S$ (SubBytes)}:
    Нелинейное биективное преобразование. Вектор $a$ разбивается на 64 байта ($a = a_{63} \| \dots \| a_0$), каждый из которых заменяется в соответствии с фиксированной перестановкой $\pi$ (S-box) в кольце вычетов $Z_{2^8}$:
    \[
    S(a) = \pi(a_{63}) \| \pi(a_{62}) \| \dots \| \pi(a_0)
    \]

    \item \textbf{Преобразование $P$ (Transposition)}:
    Перестановка байтов вектора для обеспечения диффузии. Используется фиксированная перестановка $\tau$:
    \[
    P(a) = a_{\tau(63)} \| a_{\tau(62)} \| \dots \| a_{\tau(0)}
    \]

    \item \textbf{Преобразование $L$ (Linear transformation)}:
    Линейное преобразование. Входной вектор умножается справа на фиксированную двоичную матрицу $A$ размером $64 \times 64$ над полем $GF(2)$. Операция обеспечивает зависимость каждого бита выходного вектора от всех битов входного:
    \[
    L(a) = A \cdot a
    \]
\end{enumerate}

\nlparagraph{Функция сжатия}

Функция сжатия $g_N(h, m, N)$ обновляет текущее состояние хэша $h \in V_{512}$ на основе очередного блока сообщения $m \in V_{512}$ и счетчика количества обработанных бит $N \in V_{512}$.\\

Процедура вычисления выглядит следующим образом:

\begin{enumerate}
    \item \textbf{Формирование ключа $K$:}
    Текущее состояние хэша смешивается со счетчиком длины и подвергается преобразованиям $L, P, S$:
    \[
    K = LPS(h \oplus N) = L(P(S(h \oplus N)))
    \]

    \item \textbf{Шифрование ($E$):}
    Выполняется шифрование блока сообщения $m$ на ключе $K$. Функция шифрования $E(K, m)$ состоит из 12 раундов.

    Сначала генерируются 13 раундовых ключей $K_1, \dots, K_{13}$ следующим образом:
    \[
    \begin{cases}
    K_1 = K \\
    K_i = LPS(K_{i-1} \oplus C_{i-1}), & i = 2, \dots, 13
    \end{cases}
    \]
    где $C_i$ — итерационные константы, определенные стандартом.

    Процесс преобразования состояния $State$ (изначально $State = m$):
    Для $i$ от 1 до 12 выполняется раундовое преобразование:
    \[
    State \leftarrow LPS(State \oplus K_i)
    \]
    Финальный шаг:
    \[
    E(K, m) = State \oplus K_{13}
    \]

    \item \textbf{Схема Миягучи-Пренеля:}
    Новое значение хэш-кода получается путем сложения по модулю 2 результата шифрования, исходного блока сообщения и предыдущего значения хэша:
    \[
    g_N = E(K, m) \oplus h \oplus m
    \]
\end{enumerate}

\subsubsection{Блочный шифр ГОСТ Р 34.12-2015 <<Кузнечик>>}

Для замены алгоритма \texttt{ChaCha20} в качестве примитива симметричного шифрования выбран блочный шифр <<Кузнечик>> (Kuznyechik), определенный в ГОСТ Р 34.12-2015.~\cite{gost_34_12_2015, gost_34_12_2018} Шифр оперирует 128-битными блоками данных (пространство $V_{128}$) и использует ключ длиной $k=256$ бит.\\

Алгоритм построен по архитектуре SP-сети (Substitution-Permutation network) и реализует 10 итераций преобразования состояния.

\nlparagraph{Структура алгоритма}
Процесс зашифрования представляет собой композицию раундовых функций. Для $i=1, \dots, 9$ раунд состоит из трех последовательных преобразований $LSX$:

\begin{enumerate}
    \item \textbf{Преобразование $X$ (XOR)}:
    Побитовое сложение текущего состояния блока $a$ с итерационным ключом $K_i$:
    \[
    X[K_i](a) = K_i \oplus a
    \]

    \item \textbf{Преобразование $S$ (SubBytes)}:
    Нелинейное биективное преобразование. Вектор $a$ разбивается на 16 байт, каждый из которых заменяется в соответствии с фиксированной перестановкой $\pi$ (S-Box), заданной стандартом.

    \item \textbf{Преобразование $L$ (Linear transformation)}:
    Линейное перемешивание. Стандарт определяет его как композицию 16-кратного применения преобразования сдвига регистров $R$:
    \[
    L(a) = R^{16}(a)
    \]
    На практике (и в матричном представлении) это эквивалентно умножению вектора состояния на фиксированную матрицу $M$ размером $16 \times 16$ над полем Галуа $GF(2^8)$ с неприводимым полиномом $p(x) = x^8 + x^7 + x^6 + x + 1$.
\end{enumerate}

Последний (десятый) раунд является неполным и состоит только из наложения последнего итерационного ключа: $E(a) = X[K_{10}] \circ LSX[K_9] \circ \dots \circ LSX[K_1](a)$.\\

Итерационные ключи $K_1, \dots, K_{10}$ вырабатываются из мастер-ключа (256 бит) с помощью алгоритма развертывания, использующего сеть Фейстеля.

\subsubsection{Режим MGM (Multilinear Galois Mode)}

Так как <<Кузнечик>> является блочным шифром, а протокол \texttt{WireGuard} требует потокового шифрования с аутентификацией (AEAD), используется режим MGM (ГОСТ Р 1323565.1.026—2019).~\cite{gost_1323565_1_026_2019} Данный режим стандартизирован для использования с алгоритмом <<Кузнечик>> и работает по схеме <<Encrypt-then-MAC>>.

\nlparagraph{Конфиденциальность}
Шифрование осуществляется методом гаммирования (аналог режима CTR), что позволяет обрабатывать потоки данных произвольной длины без необходимости выравнивания (padding).

\begin{enumerate}
    \item \textbf{Инициализация:} Формируется начальное значение счетчика $T_1$ на основе уникального вектора (Nonce) и ключа.
    \item \textbf{Генерация гаммы:} Для каждого блока данных $i$ вырабатывается блок гаммы $Z_i$ путем зашифрования текущего значения счетчика:
    \[
    Z_i = E_K(T_i), \quad T_{i+1} = \text{incr}(T_i)
    \]
    где $\text{incr}$ — операция инкремента в кольце вычетов по модулю $2^{128}$.
    \item \textbf{Шифрование:} Шифротекст $C_i$ получается сложением по модулю 2 блока открытого текста $P_i$ с гаммой:
    \[
    C_i = P_i \oplus \text{MSB}_{|P_i|}(Z_i)
    \]
\end{enumerate}

\nlparagraph{Имитозащита}
Для обеспечения целостности и аутентификации вычисляется имитовставка $TAG$ с использованием мультилинейной функции. Особенностью MGM является использование схемы Вегмана-Картера, где для умножения каждого блока данных используется свой уникальный секретный множитель $H_j$.\\

Множители $H_j$ вырабатываются путем шифрования значений счетчика, отличных от тех, что использовались для гаммирования (обеспечивается разделением домена, например, установкой старшего бита):
\[
H_j = E_K(\text{Counter}_j^{\text{auth}})
\]

Финальная имитовставка вычисляется как:
\[
\text{TAG} = \text{MSB}_{\text{len}} \left( E_K(\text{Nonce}) \oplus \sum_{j} (A_j \otimes H_j) \oplus \sum_{k} (C_k \otimes H_{k+\dots}) \right)
\]
где операции сложения и умножения ($\otimes$) выполняются в поле $GF(2^{128})$. Использование уникальных множителей $H_j$ обеспечивает доказуемую стойкость режима и возможность параллельного вычисления имитовставки.

\subsubsection{Протокол выработки общего ключа VKO ГОСТ Р 34.10-2012}

Для замены протокола \texttt{Curve25519} используется алгоритм выработки общего ключа VKO (Выработка Ключа Обмена), реализуемый на эллиптических кривых, определенных в ГОСТ Р 34.10-2012. ~\cite{gost_34_10_2012}

\nlparagraph{Математическая модель}
Алгоритм оперирует элементами группы точек эллиптической кривой $E$, заданной уравнением над конечным простым полем $F_p$:
\[
y^2 \equiv x^3 + ax + b \pmod p
\]
Параметры кривой ($a, b, p, q, P, m$) должны удовлетворять требованиям раздела 5.2 стандарта.\\

Пусть Участник A обладает парой ключей $(d_A, Q_A)$, где:
\begin{itemize}
    \item $d_A$ — секретный ключ (целое число, $0 < d_A < q$);
    \item $Q_A = d_A P$ — открытый ключ (точка кривой), вычисленный как кратная точка от базовой точки $P$.
\end{itemize}
Аналогично, Участник B обладает парой $(d_B, Q_B)$.\\

Процедура выработки общего секрета на стороне Участника A выглядит следующим образом:

\begin{enumerate}
    \item \textbf{Валидация ключа партнера:} Проверяется, что точка $Q_B$ удовлетворяет уравнению кривой и не является нулевой точкой $O$.

    \item \textbf{Вычисление общей точки:} Вычисляется точка $C$ (Common Point) умножением открытого ключа партнера на свой секретный ключ и кофактор кривой:
    \[
    C = (n \cdot d_A) \cdot Q_B
    \]
    где $n = m/q$ — кофактор (индекс подгруппы), обеспечивающий нахождение точки в подгруппе порядка $q$.
    В силу свойств группы точек эллиптической кривой участники получат одну и ту же точку:
    \[
    C = n \cdot d_A \cdot (d_B P) = n \cdot d_B \cdot (d_A P) = (n \cdot d_B) \cdot Q_A
    \]

    \item \textbf{Вывод ключа (KDF):} Результирующий общий ключ $K$ формируется путем хэширования x-координаты полученной точки $x_C$ совместно с дополнительной ключевой информацией:
    \[
    K = h(UKM || \text{Vec}(x_C))
    \]
    где:
    \begin{itemize}
        \item $h()$ — хэш-функция ГОСТ Р 34.11-2012 (<<Стрибог>>);
        \item $\text{Vec}(x_C)$ — двоичное представление координаты $x$ точки $C$;
        \item $UKM$ (User Keying Material) — 64-битное случайное число (Nonсe), передаваемое открыто для обеспечения уникальности сессионного ключа.
    \end{itemize}
\end{enumerate}

\section{Теоретическая часть}

\subsection{Основные понятия}

Основная часть дипломной работы построена на основе термина "виртуальный криптографический сетевой интерфейс", который в свою очередь является составным.
Для того, чтобы дать ему определение, первоочередно следует определить три ключевых понятия, которые он включает:
\begin{itemize}
    \item криптографическое средство защиты информации (СКЗИ);
    \item виртуальная частная сеть (VPN);
    \item виртуальный сетевой интерфейс (VNI).
\end{itemize}

\subsubsection{Средство криптографической защиты информации}

В соответствии с ГОСТ Р 50922-2006 "Защита информации. Основные термины и определения", под средством криптографической защиты информации (СКЗИ) понимается средство защиты информации, реализующее алгоритмы криптографического преобразования информации~\cite[с. 4]{gost_50922_2006}.\\

В более широком смысле СКЗИ можно назвать набором аппаратных, программных или программно-аппаратных средств, обеспечивающих одну из следующих функций~\cite[с. 1]{pp313}:
\begin{itemize}
    \item шифрование и расшифрование данных;
    \item вычисление имитовставки;
    \item изготовление ключевых документов;
    \item формирование и проверка электронной подписи;
    \item кодирование и декодирование данных.
\end{itemize}

\subsubsection{Виртуальная частная сеть}

Понятие виртуальной частной сети определяется в ГОСТ IEC 60050-732-2017 "Международный электротехнический словарь. Часть 732. Технологии компьютерных сетей".
Согласно этому стандарту, <<виртуальная частная сеть (VPN) --- это компьютерная сеть, в которой для передачи данных используют промежуточные сети (например, Интернет), прозрачные для пользователей и не вводящие ограничения на протоколы, в результате чего сеть функционирует как локальная компьютерная сеть>>~\cite[с. 2]{gost_60050_732_2017}.
Примечание к стандарту указывает, что при передаче данных обычно используется туннелирование.\\

Говоря о VPN в контексте информационной безопасности, данное определение следует дополнить.
Основной задачей VPN является не просто объединение сетей, но также обеспечение защищенного обмена информацией между ними.
Фактически VPN выступает в роли виртуальной сети, которая создает защищенный канал (туннель) между участниками такого обмена.\\

Таким образом, более точным определением для VPN будет являться:
VPN --- обобщённое название технологий, позволяющих обеспечить одно или несколько сетевых соединений поверх другой сети (как правило, публичной), требующих аутентификации клиентов и использующих шифрование для обеспечения конфиденциальности и целостности передаваемых данных.\\

В зависимости от применяемых протоколов и назначения, можно выделить три вида \texttt{VPN}:
\begin{itemize}
    \item \textbf{Узел-узел (Host-to-Host)}:
    данный тип соединения устанавливает защищенный туннель между двумя отдельными компьютерами в сети.
    Такой тип соединения позволяет обеспечить зашифрованный обмен информацией в рамках недоверенной сетевой среды, ограничивая при этом доступ только участвующим в обмене компьютерам;
    \item \textbf{Узел-сеть (Remote Access VPN)}:
    этот тип соединения предназначен для обеспечения безопасного удаленного доступа.
    Он позволяет отдельным пользователям, находящимся вне корпоративной сети, безопасно подключаться к ресурсам компании, используя при этом публичные сети;
    \item \textbf{Сеть-сеть (Site-to-Site VPN)}:
    последний тип VPN используется для безопасного объединения нескольких территориально распределенных локальных сетей в единую корпоративную сеть через Интернет.
    VPN-шлюзы, установленные на границе каждой из локальных сетей, создают между собой постоянный зашифрованный туннель, через который проходит весь трафик.
\end{itemize}

\subsubsection{Сетевой адаптер}

Сетевой адаптер --- это физическое аппаратное устройство, которое обеспечивает непосредственное подключение компьютера к сетевой среде.

\subsubsection{Сетевой интерфейс}

Сетевой интерфейс --- это логическая сущность в ядре операционной системы. Именно в интерфейсе присваиваются IP-адреса и через них приложения отправляют и получают сетевые пакеты.

\input{src/embeds/tikz/00_network_interface}

\subsubsection{Виртуальный сетевой интерфейс}

В ГОСТ отсутствует прямое определение для термина <<виртуальный сетевой интерфейс>>. Однако его можно вывести, опираясь на техническую документацию ядра \texttt{Linux}.\\

Виртуальный сетевой интерфейс --- это программный компонент, который имитирует работу физического сетевого адаптера (сетевой карты).
В отличие от физического интерфейса, который представляет собой физическое устройство, подключаемое к сети, виртуальный интерфейс существует исключительно на программном уровне.
Операционная система и приложения взаимодействуют с виртуальным интерфейсом так же, как и с физическим.

\subsubsection{Виртуальный криптографический сетевой интерфейс}

Исходя из трех вышеописанных понятий, можно сформулировать комплексное определение.\\

Виртуальный криптографический сетевой интерфейс --- это виртуальный сетевой интерфейс, который на программном уровне реализует функции средства криптографической защиты информации для обеспечения безопасной передачи данных, как правило, в рамках виртуальной частной сети (VPN).

\subsubsection{Эталонная модель взаимодействия открытых систем}

Эталонная модель ВОС (OSI) --- это теоретическая модель, разработанная Международной организацией по стандартизации (ISO)~\cite[28]{iso_7498_1}, регламентированная государственным стандартом ГОСТ Р ИСО/МЭК 7498-1-99\cite[3]{gost_28906_91}, созданная для обеспечения общей основы скоординированной разработки стандартов в области обмена информацией.
Модель описывает функциональную среду ВОС и вводит концепцию семиуровневой архитектуры, где каждый уровень предоставляет услуги смежному верхнему уровню, используя функции смежного нижнего уровня:
\begin{itemize}
    \item \textbf{Прикладной уровень (Application Layer)}: является верхним уровнем модели и предоставляет прикладным процессам средства доступа к функциональной среде ВОС. Данный уровень обеспечивает все услуги, непосредственно воспринимаемые прикладными процессами и необходимые для обмена информацией;
    \item \textbf{Представления уровень (Presentation Layer)}: устанавливает способы представления информации, передаваемой между прикладными объектами. Основная задача уровня --- гарантировать синтаксическую независимость прикладных объектов путем выбора общего синтаксиса передачи и выполнения необходимых преобразований;
    \item \textbf{Сеансовый уровень (Session Layer)}: предоставляет средства, необходимые для организации и синхронизации диалога между взаимодействующими объектами уровня представления, а также для административного управления обменом данными;
    \item \textbf{Транспортный уровень (Transport Layer)}: обеспечивает надежную и экономичную передачу данных между логическими объектами сеансового уровня в межоконечном режиме. Уровень оптимизирует использование доступных услуг сетевого уровня и обеспечивает требуемое качество услуг;
    \item \textbf{Сетевой уровень (Network Layer)}: предоставляет средства для установления, поддержания и разъединения соединений между открытыми системами, а также обеспечивает маршрутизацию и ретрансляцию данных через одну или несколько подсетей. Уровень скрывает от транспортного уровня детали использования нижележащих ресурсов передачи;
    \item \textbf{Канальный уровень (Data Link Layer)}: предоставляет функциональные и процедурные средства для установления, поддержания и освобождения соединений звена данных, а также для обмена блоками данных (СБД) между объектами сетевого уровня. Важной функцией является обнаружение и, по возможности, исправление ошибок, возникающих на физическом уровне;
    \item \textbf{Физический уровень (Physical Layer)}: обеспечивает механические, электрические, функциональные и процедурные средства для активизации, поддержки и деактивизации физических соединений, предназначенных для побитовой передачи данных через физическую среду между объектами уровня звена данных.
\end{itemize}

\input{src/embeds/tikz/01_osi_model}

\subsubsection{Модель TCP/IP}
Модель TCP/IP --- это практическая четырехуровневая модель стека протоколов, на основе которой функционирует современный Интернет.~\cite{rfc1180, gost_53531_2009}
В отличие от теоретической модели OSI, TCP/IP описывает реальный набор протоколов, обеспечивающих передачу данных между устройствами в глобальных сетях.\\

Данная модель регламентирует обмен данными и управление в сетях передачи данных и включает следующие уровни:
\begin{itemize}
    \item \textbf{Прикладной уровень (Application Layer)}: объединяет функции прикладного и сеансового уровня модели \texttt{OSI}. На этом уровне осуществляется обмен данными между программными компонентами, реализуются специфические протоколы управления и мониторинга оборудования (например, \texttt{HTTP}, \texttt{SMTP}, \texttt{DNS});
    \item \textbf{Транспортный уровень (Transport Layer)}: обеспечивает обмен данными между узлами сети, связанными непосредственно или через несколько сетей. Согласно стандарту, на этом уровне применяются два основных протокола \texttt{TCP} и \texttt{UDP};
    \item \textbf{Сетевой уровень (Internet Layer)}: отвечает за межсетевое взаимодействие и маршрутизацию пакетов. Идентификация узлов  в пределах сети осуществляется с помощью уникальных IP-адресов. Уровень обеспечивает доступ к информации о станции непосредственно или косвенно через шлюзы;
    \item \textbf{Канальный уровень (Link Layer)}: объединяет функции физического и канального уровней. Стандарт определяет использование интерфейсов локальной сети на основе протокола CSMA/CD, в частности спецификации Ethernet для физического соединения компонентов.
\end{itemize}

\input{src/embeds/tikz/02_tcp_ip_model}

\subsection{Теоретические основы}

\subsubsection{Сетевой стек операционной системы Linux}

Для понимания принципов работы виртуального сетевого интерфейса \texttt{Linux} требуется сначала разобраться в сетевой подсистеме операционной системы. Сетевой стек ОС Linux представляет собой модульную иерархическую структуру, реализующую семейство протоколов TCP/IP. \\

Архитектурно сетевая подсистема разделена на два уровня привилегий:
\begin{enumerate}
    \item \textbf{Пространство пользователя (User Space)}: на данном уровне располагаются прикладные приложения, которые работают с данными по средствам стандартных системных вызовов (\texttt{Socket API});
    \item \textbf{Пространство ядра (Kernel Space)}: на уровне ядра, в свою очередь, реализуются основные механизмы транспортного, сетевого и канального уровней, а также взаимодействие с аппаратными драйверами устройств.
\end{enumerate}

Основной структурой данных, используемой ядром Linux для управления сетевыми пакетами, является буфер сокета (\texttt{sk\_buff}). Данная структура позволяет работать с данными на различных уровнях стека без лишнего копирования их в память.

\nlparagraph{Механизм обработки и передачи данных}

Процесс прохождения данных через сетевой стек базируется на двух фундаментальных операциях, обеспечивающих абстракцию уровней друг от друга:

\begin{itemize}
    \item \textbf{Инкапсуляция (Encapsulation)}: процесс, инициируемый при передаче данных от прикладного уровня к физическому. По мере прохождения через стек, каждый уровень обрабатывает данные, полученные от вышестоящего уровня как полезную нагрузку, и добавляет к ним собственный заголовок (и концевик на канальном уровне). Эти заголовки содержат управляющую информацию (адреса, контрольные суммы, флаги), необходимую для корректной доставки и обработки пакета на соответствующем уровне получателя;

    \item \textbf{Декапсуляция (Decapsulation)}: обратный процесс, происходящий при приеме данных. Сетевой интерфейс передает полученный кадр в ядро, где происходит последовательный анализ и удаление служебных заголовков. На каждом этапе стек определяет протокол вышестоящего уровня и передает ему очищенную полезную нагрузку (payload), пока исходные данные не достигнут приложения в пространстве пользователя.
\end{itemize}

\input{src/embeds/tikz/06_network_stack}

\subsubsection{Краткий анализ принципов работы WireGuard}

\texttt{WireGuard} представляет собой протокол организации защищенных сетевых туннелей (\textit{secure network tunnel}), работающий на сетевом уровне (\texttt{Layer 3}) модели \texttt{OSI}. \texttt{WireGuard} осуществляет инкапсуляцию IP-пакетов для передачи поверх транспортного протокола UDP, при этом он сильно снижает поверхность для атаки за счет своего крайне малого размера и использования фиксированного набора современных криптографических примитивов.~\cite{wireguard} \\

\noindent Сам по себе \texttt{WireGuard} является довольно уникальным протоколом, в первую очередь, из-за некоторых ключевых концепций, которые заложены в его архитектуру:

\nlparagraph{Одноранговая архитектура и идентификация}

\texttt{WireGuard} отходит от традиционной модели <<клиент-сервер>>.
В отличие от стандартного VPN протокола, в его архитектуре все участники сети являются равноправными узлами (так называемыми пирами).
При этом идентификация каждого узла проходит по публичным ключам, которые генерируются на основе эллиптической кривой \texttt{Curve25519}. \\

Протокол реализует свойство <<молчаливости>> (\textit{silence property}): узел не отправляет ответы на неаутентифицированные пакеты. Если входящий пакет не расшифровывается корректно известным ключом, он отбрасывается без уведомления отправителя. Это делает узлы невидимыми для сетевого сканирования.

\nlparagraph{Протокол \texttt{Noise} и установление сессии}

Процедура рукопожатия (\textit{Handshake}) построена на базе фреймворка \textbf{Noise Protocol Framework} (шаблон \texttt{IKpsk2}). Такой механизм позволяет обеспечить:
\begin{itemize}
    \item \textbf{Взаимную аутентификацию}: идентификация узлов производится путем перекрестной проверки их статических открытых ключей (\texttt{Curve25519}) в процессе обмена сообщениями;
    \item \textbf{Совершенную прямую секретность (PFS):} для каждой сессии, при помощи протокола обмена ключами Диффи-Хеллмана, генерируются эфемерные ключи, которые уничтожаются сразу после завершения рукопожатия;
    \item \textbf{Минимизацию задержек:} установление соединения занимает всего 1.5 RTT (Round Trip Time). Инициатор может отправлять зашифрованные данные сразу после первого сообщения-рукопожатия.
\end{itemize}

\nlparagraph{Криптографическая маршрутизация (Cryptokey Routing)}

В основе логики обработки трафика лежит жесткая привязка публичного ключа пира к списку разрешенных IP-адресов (\texttt{AllowedIPs}). Этот механизм объединяет функции таблицы маршрутизации и межсетевого экрана (\texttt{ACL}):
\begin{itemize}
    \item \textbf{Исходящий трафик:} при отправке пакета \texttt{WireGuard} выбирает пира, в чьем списке \texttt{AllowedIPs} содержится IP-адрес назначения, и шифрует пакет соответствующим публичным ключом;
    \item \textbf{Входящий трафик:} после расшифровки пакета проверяется, соответствует ли IP-адрес источника (внутри туннеля) списку \texttt{AllowedIPs}, привязанному к ключу отправителя. При несовпадении пакет отбрасывается, что предотвращает IP-спуфинг.
\end{itemize}

\nlparagraph{Механизмы защиты}

Протокол включает встроенные меры противодействия распространенным сетевым атакам:
\begin{itemize}
    \item \textbf{Защита от DoS (Cookie):} для предотвращения истощения \texttt{CPU} дорогостоящими операциями над эллиптическими кривыми используется механизм возвратных cookie. Под нагрузкой узел может потребовать от инициатора повторить запрос с включением криптографического токена, подтверждающего владение IP-адресом, без создания состояния на сервере;
    \item \textbf{Защита от повторного воспроизведения (Replay Attack):} используется система монотонно возрастающих счетчиков (nonce) и скользящего окна на стороне получателя;
    \item \textbf{Отсутствие криптографической гибкости:} \texttt{WireGuard} использует безальтернативный набор примитивов (\texttt{ChaCha20}, \texttt{Poly1305}, \texttt{BLAKE2s}, \texttt{Curve25519}). Это исключает класс атак на понижение безопасности (\textit{downgrade attacks}) и упрощает реализацию.
\end{itemize}

\subsection{Модули ядра \texttt{Linux}}

Основным механизмом расширения функциональности ядра \texttt{Linux}, не требующим его повторной сборки и перезагрузки системы, является использование загружаемых модулей ядра (\texttt{Loadable Kernel Modules, LKM}).~\cite{kernel_modules_doc}\\

Данный механизм позволяет динамически загружать и выгружать программный код в пространство ядра работающей операционной системы. Это обеспечивает модульность и гибкость архитектуры: драйверы устройств, файловые системы и реализации сетевых протоколов могут существовать в виде отдельных компонентов, подключаемых только по мере необходимости.\\

С архитектурной точки зрения модуль представляет собой специализированный объектный файл, который связывается (линкуется) с ядром во время выполнения. Жизненный цикл любого модуля определяется двумя ключевыми этапами:

\begin{itemize}
    \item \textbf{Инициализация}: процесс, выполняемый при загрузке модуля в память. На этом этапе модуль регистрирует свои функции в соответствующих подсистемах ядра и выделяет необходимые ресурсы;
    \item \textbf{Деинициализация}: процесс, выполняемый при выгрузке модуля. Он отвечает за корректное освобождение ресурсов и удаление регистрации, возвращая систему в исходное состояние.
\end{itemize}

Именно этот архитектурный подход используется для расширения криптографической подсистемы: новые алгоритмы шифрования и хэширования оформляются в виде модулей, которые регистрируют свои реализации через интерфейсы \texttt{Crypto API}.

\subsection{Криптографическая подсистема ядра \texttt{Linux}}

Криптографическая подсистема ядра Linux (\texttt{Linux Kernel Crypto API}) представляет собой унифицированный программный интерфейс, предоставляющий доступ к криптографическим примитивам для других подсистем ядра (например, сетевого стека или дискового шифрования).~\cite{crypto_api_doc}\\

Архитектура фреймворка позволяет абстрагироваться от конкретной реализации алгоритма, прозрачно поддерживая как программные, так и аппаратно-ускоренные решения. Реализация любого криптографического алгоритма в рамках этой подсистемы рассматривается как <<преобразование>> (transformation), которое регистрируется в ядре и становится доступным для использования через стандартные вызовы API.

\subsubsection{Классификация криптографических примитивов}

Архитектура \texttt{Crypto API} классифицирует алгоритмы не только по их функциональному назначению, но и по способу взаимодействия с памятью. Каждому классу соответствует свой набор абстракций и структур данных.\\

Ниже приведен перечень основных типов алгоритмов, поддерживаемых подсистемой:

\nlparagraph{Симметричные шифры (SKCIPHER)}
Аббревиатура расшифровывается как \textit{Symmetric Key Cipher}. Это основной класс алгоритмов для шифрования данных произвольной длины.
\begin{itemize}
    \item \textbf{Назначение:} реализация режимов работы блочных шифров (CBC, CTR, XTS) или потоковых шифров;
    \item \textbf{Особенности:} ключевой особенностью данного API является работа с данными через механизм \texttt{scatterlist}. Это позволяет обрабатывать данные, фрагментированные в физической памяти (например, сетевые пакеты, части которых располагаются в разных страницах памяти), без их предварительного копирования в непрерывный буфер.
\end{itemize}

\nlparagraph{2. Базовые блочные шифры (CIPHER)}
Низкоуровневый интерфейс, реализующий преобразование ровно одного блока фиксированной длины (например, 8 байт для ГОСТ 28147-89 или 16 байт для AES).
\begin{itemize}
    \item \textbf{Назначение:} используется преимущественно как строительный блок для создания более сложных конструкций (шаблонов), таких как \texttt{skcipher} или хэш-функции. Напрямую прикладными модулями используется редко;
    \item \textbf{Особенности:} работает синхронно и только с прямыми адресами памяти, не поддерживая \texttt{scatterlist}.
\end{itemize}

\nlparagraph{Аутентифицированное шифрование (AEAD)}
Класс \textit{Authenticated Encryption with Associated Data} объединяет операции шифрования и вычисления имитовставки (\texttt{MAC}) в один атомарный вызов.
\begin{itemize}
    \item \textbf{Назначение:} защита сетевого трафика в современных VPN-протоколах (\texttt{WireGuard}, \texttt{IPsec}). Гарантирует целостность не только зашифрованной полезной нагрузки, но и открытых заголовков пакета;
    \item \textbf{Особенности:} принимает на вход два потока данных: ассоциированные данные (которые не шифруются, но защищаются от подделки) и данные для шифрования.
\end{itemize}

\nlparagraph{Протоколы согласования ключей (KPP)}
Аббревиатура расшифровывается как \textit{Key-agreement Protocol Primitives}. Этот класс абстрагирует операции асимметричной криптографии, необходимые для выработки общего секрета.
\begin{itemize}
    \item \textbf{Назначение:} реализация механизмов рукопожатия (handshake), таких как \texttt{Diffie-Hellman} (\texttt{DH}), \texttt{ECDH} и их аналогов, включая \texttt{VKO} (ГОСТ Р 34.10-2012);
    \item \textbf{Принцип работы:} реализация предоставляет три основные операции: загрузка собственного секретного ключа, генерация соответствующего публичного ключа и вычисление общего секрета на основе принятого публичного ключа удаленной стороны.
\end{itemize}

\nlparagraph{Хэш-функции (SHASH / AHASH)}
Интерфейс для вычисления дайджестов сообщений и кодов аутентификации (\texttt{HMAC}). В ядре разделен на два подтипа:
\begin{itemize}
    \item \textbf{SHASH (Synchronous Hash):} оптимизирован для программных реализаций. Операции выполняются в контексте вызывающего процесса без переключений контекста;
    \item \textbf{AHASH (Asynchronous Hash):} предназначен для аппаратных ускорителей или обработки больших объемов данных. Может возвращать управление до завершения вычисления, используя механизм callback-функций.
\end{itemize}

\nlparagraph{Асимметричные шифры (AKCIPHER)}
Класс \textit{Asymmetric Key Cipher} предназначен для алгоритмов с публичным ключом общего назначения.
\begin{itemize}
    \item \textbf{Назначение:} реализация алгоритмов \texttt{RSA}, создание и проверка электронных цифровых подписей (\texttt{DSA}, \texttt{ECDSA}), а также шифрование небольших блоков данных асимметричным методом.
\end{itemize}

\nlparagraph{Генераторы случайных чисел (RNG)}
Обеспечивает унифицированный интерфейс к источникам энтропии и детерминированным генераторам псевдослучайных чисел (\texttt{DRBG}), необходимых для генерации ключей, векторов инициализации и одноразовых кодов.

\subsubsection{Протокол \texttt{Netlink}}

Для управления виртуальным интерфейсом и мониторинга его состояния необходим надежный канал связи между пространством ядра (\texttt{kernelspace}) и пространством пользователя (\texttt{userspace}). В современной архитектуре Linux стандартом для таких задач является протокол \texttt{Netlink}.~\cite{netlink_doc}

Это механизм межпроцессного взаимодействия (\texttt{IPC}), который эмулирует сетевое взаимодействие: обмен данными происходит через сокеты, что позволяет использовать стандартные системные вызовы для отправки и получения конфигурационных команд. В отличие от устаревшего системного вызова \texttt{ioctl}, \texttt{Netlink} является асинхронным и событийно-ориентированным протоколом.

\nlparagraph{Архитектура обмена данными}

Взаимодействие строится на обмене пакетированными сообщениями. Протокол поддерживает две основные модели коммуникации:
\begin{itemize}
    \item \textbf{Синхронные запросы (Unicast):} приложение отправляет команду (например, <<добавить пира>> или <<получить список ключей>>) и ожидает от ядра подтверждения или запрошенных данных;
    \item \textbf{Асинхронные уведомления (Multicast):} ядро может самостоятельно инициировать передачу данных группе подписчиков. Это критически важно для VPN-интерфейсов, так как позволяет мгновенно уведомлять приложения об изменении состояния соединения (например, о завершении рукопожатия) без необходимости постоянного опроса (polling).
\end{itemize}

Гибкость протокола обеспечивается благодаря тому, что данные передаются в формате \texttt{TLV} (\texttt{Type-Length-Value}). Вместо заданных в исходном коде структур языка <<\texttt{C}>>, сообщения формируются как набор атрибутов. Это позволяет добавлять новые параметры конфигурации в будущих версиях модуля, не нарушая работу старых утилит управления (обратная совместимость).

\nlparagraph{Generic Netlink}

Классический \texttt{Netlink} имеет ограничение на количество поддерживаемых протоколов. Для решения этой проблемы был разработан механизм \texttt{Generic Netlink}.\\

Он выступает в роли мультиплексора, позволяя загружаемым модулям ядра (таким как \texttt{WireGuard}) динамически регистрировать собственные "семейства" команд. При регистрации модуль получает уникальный идентификатор, по которому утилиты из пространства пользователя могут к нему обращаться. Это избавляет разработчика от необходимости резервировать статические номера протоколов в исходном коде ядра.
